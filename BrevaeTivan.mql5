//+==================================================================+
//|                  YOU TRADE EA - SMART ORDER MANAGER v1.3 FINAL   |
//|        Grid Pending + Visual TP/SL + Cooldown + Dual Dashboard  |
//+==================================================================+
//|  Copyright ¬© 2025 - You Trade EA Development Team                |
//|  Versione 1.3 FINAL - Professional Grid System + Dual Control    |
//+------------------------------------------------------------------+
#property copyright "You Trade EA ¬© 2025"
#property link      "https://youtrade-ea.com"
#property version   "1.30"
#property description "Grid Pending Orders | Visual TP/SL | Cooldown | BUY/SELL Direct Control"
#property description "Zero Spread Grid | Complete Visualization | Professional System"
#property strict

#include <Trade\Trade.mqh>

//+------------------------------------------------------------------+
//| ENUMERAZIONI                                                      |
//+------------------------------------------------------------------+
enum ENUM_DIRECTION {
    LONG,           // Long (Buy) - Acquisto
    SHORT           // Short (Sell) - Vendita
};

enum ENUM_LOT_MODE {
    STANDARD,       // Standard - Volume Fisso
    PROGRESSION     // Progression - Incremento Lineare
};

enum ENUM_SYSTEM_STATE {
    STATE_IDLE, STATE_MAIN_OPENING, STATE_MAIN_OPEN,
    STATE_GRID_ACTIVE, STATE_CLOSING, STATE_ERROR
};

enum ENUM_GRID_ORDER_TYPE {
    GRID_MARKET,    // Grid con ordini Market (v1.2 style)
    GRID_PENDING    // Grid con ordini Pending (v1.3 NUOVO!)
};

//+------------------------------------------------------------------+
//| INPUT PARAMETERS - VERSIONE 1.3 FINAL                            |
//+------------------------------------------------------------------+
input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üéØ ORDINE PRINCIPALE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input double MainLotSize = 1.0;                         
// Volume in lotti (0.01=micro, 0.1=mini, 1.0=standard)

input int MainTakeProfitPips = 100;                     
// Take Profit in pips dal prezzo entry

input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üìç ORDINI LIMIT/STOP ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input int LimitOffsetPips = 3;
// Distanza dal prezzo corrente per LIMIT orders
// CONSIGLIO: 2-5 pips per fill rapido con saving

input int StopOffsetPips = 5;
// Distanza dal prezzo corrente per STOP orders
// CONSIGLIO: 5-10 pips per breakout trading

input int LimitTimeoutSeconds = 300;
// Timeout ordini pending (secondi). 0 = infinito

input bool AutoRetryLimit = true;
// Riprova automaticamente se pending non eseguito

input int MaxLimitRetries = 3;
// Numero massimo tentativi riposizionamento

input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üõ°Ô∏è GRID HEDGING PROTEZIONE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input ENUM_GRID_ORDER_TYPE GridOrderType = GRID_PENDING;
// MARKET: Ordini market immediati (spread pieno)
// PENDING: Ordini STOP pending (ZERO SPREAD!)

input int GridActivationPips = 20;                      
// Distanza attivazione grid (pips movimento contro)

input int GridSpacing = 15;                             
// Distanza tra livelli grid consecutivi

input int MaxGridLevels = 7;                            
// Numero massimo livelli grid

input int GridTakeProfitPips = 25;                      
// TP per ogni ordine grid (MODIFICABILE su grafico)

input int FirstGridStopLoss = 30;                       
// SL SOLO primo grid (pips) - UNICO RISCHIO REALE

input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üöÄ TRAILING GRID (PROTEZIONE PROFITTI) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input bool EnableTrailingGrid = true;
// Grid segue profitto verso breakeven

input int TrailingStartPips = 30;
// Profit per attivare trailing (pips)

input int TrailingStepPips = 10;
// Avanzamento grid ogni X pips profit

input int TrailingMinDistance = 15;
// Distanza minima grid da prezzo (pips)

input bool TrailToBreakeven = true;
// Permetti grid arrivare fino a entry price

input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ‚è±Ô∏è COOLDOWN SYSTEM (PROTEZIONE BROKER) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input bool EnableCooldown = true;
// Attiva sistema cooldown per evitare overload

input int CooldownUpSeconds = 15;
// Cooldown dopo trailing UP (secondi)

input int CooldownDownSeconds = 10;
// Cooldown dopo nuovo grid level DOWN

input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üí∞ GESTIONE LOT SIZE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input ENUM_LOT_MODE LotSizeMode = STANDARD;             
// STANDARD: Volume fisso tutti grid
// PROGRESSION: Incremento lineare

input double StandardLotSize = 0.02;                    
// [STANDARD] Volume fisso grid

input double ProgressionStartLot = 0.1;                 
// [PROGRESSION] Volume iniziale

input double ProgressionIncrement = 0.1;                
// [PROGRESSION] Incremento lineare per livello

input double ProgressionMaxLot = 1.0;                   
// [PROGRESSION] Cap massimo volume

input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üîê PROTEZIONE ACCOUNT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input int MagicNumber = 987654;                         
// ID univoco EA

input int Slippage = 3;                                 
// Slippage massimo accettabile (pips)

input bool EnableEmergencyStop = true;                  
// Stop emergenza automatico

input double EmergencyStopPercent = 35.0;               
// Drawdown % per emergency stop

input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üé® GRAFICA ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input color MainLineColor = clrDodgerBlue;
input color GridLineColor = clrOrange;
input color GridPendingColor = clrRed;
input color GridFilledColor = clrCrimson;
input color TPLineColor = clrLime;
input color TPMarkerColor = clrLimeGreen;
input color SLMarkerColor = clrDodgerBlue;
input color PanelBackColor = clrDarkSlateGray;
input color PanelTextColor = clrWhite;

input group "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üîî ALERT & LOGGING ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
input bool EnableAlerts = true;
// Attiva alert popup per eventi importanti

input bool EnablePushNotifications = false;
// Notifiche push su mobile (richiede configurazione MT5)

input bool DetailedLogging = true;
// Log dettagliato di tutte le operazioni

//+------------------------------------------------------------------+
//| VARIABILI GLOBALI                                                 |
//+------------------------------------------------------------------+
CTrade trade;

ENUM_SYSTEM_STATE currentState = STATE_IDLE;
bool systemActive = false;
datetime systemStartTime = 0;

// Pending order management
ulong pendingOrderTicket = 0;
datetime pendingOrderTime = 0;
int pendingRetryCount = 0;
ENUM_DIRECTION pendingDirection = LONG;
string pendingOrderType = "";  // "MARKET", "LIMIT", "STOP"

// Main position
ulong mainTicket = 0;
double mainOpenPrice = 0;
double mainCurrentProfit = 0;
double mainTakeProfit = 0;
ENUM_DIRECTION mainDirection = LONG;

// Grid state
bool gridActive = false;
int currentGridLevel = 0;
ulong gridTickets[20];
ulong gridPendingTickets[20];
double gridOpenPrices[20];
double gridLotSizes[20];
double gridTakeProfits[20];
double gridStopLosses[20];
datetime gridOpenTimes[20];
bool gridIsFilled[20];
double currentGridTP = 0;

// Trailing grid
double trailedActivationPrice = 0;
double lastTrailedPrice = 0;
bool trailingActive = false;

// Cooldown system
bool cooldownActive = false;
datetime cooldownEndTime = 0;
string cooldownType = "";

// Performance
double totalGridProfit = 0;
double totalSystemProfit = 0;
double maxDrawdown = 0;
double currentDrawdown = 0;

// Weighted average
double priceTimesSizeSummation = 0;
double totalLotSizeSummation = 0;
double weightedAvgPrice = 0;

// Stats
int totalGridCycles = 0;
int totalGridOrders = 0;
int totalTrailingShifts = 0;
int totalPendingCanceled = 0;
int pendingOrdersCount = 0;
int filledOrdersCount = 0;

//+------------------------------------------------------------------+
//| Expert initialization                                             |
//+------------------------------------------------------------------+
int OnInit() {
    Print("‚ïê‚ïê‚ïê YOU TRADE EA v1.3 FINAL - INIZIALIZZAZIONE ‚ïê‚ïê‚ïê");
    
    trade.SetExpertMagicNumber(MagicNumber);
    trade.SetDeviationInPoints(Slippage);
    trade.SetTypeFilling(ORDER_FILLING_FOK);
    trade.SetAsyncMode(false);
    
    if(AccountInfoInteger(ACCOUNT_MARGIN_MODE) != ACCOUNT_MARGIN_MODE_RETAIL_HEDGING) {
        Alert("‚ö†Ô∏è Account deve essere HEDGING mode!");
    }
    
    ArrayInitialize(gridTickets, 0);
    ArrayInitialize(gridPendingTickets, 0);
    ArrayInitialize(gridOpenPrices, 0);
    ArrayInitialize(gridLotSizes, 0);
    ArrayInitialize(gridTakeProfits, 0);
    ArrayInitialize(gridStopLosses, 0);
    ArrayInitialize(gridOpenTimes, 0);
    ArrayInitialize(gridIsFilled, false);
    
    CreateDashboard();
    CreateDualControlButtons();
    
    Print("‚úÖ EA Inizializzato - DUAL CONTROL MODE");
    Print("üìä Symbol: ", _Symbol);
    Print("‚öôÔ∏è Magic: ", MagicNumber);
    Print("üõ°Ô∏è Grid Type: ", GridOrderType == GRID_PENDING ? "PENDING (Zero Spread!)" : "MARKET");
    Print("‚è±Ô∏è Cooldown: ", EnableCooldown ? "ATTIVO" : "OFF");
    Print("üéõÔ∏è Control: BUY/SELL Dual Dashboard");
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization                                          |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    Print("‚ïê‚ïê‚ïê YOU TRADE EA v1.3 FINAL - DEINIZIALIZZAZIONE ‚ïê‚ïê‚ïê");
    
    RemoveAllObjects();
    
    if(systemActive) {
        SaveSessionStatistics("EA Removed");
    }
    
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Expert tick function                                              |
//+------------------------------------------------------------------+
void OnTick() {
    // Gestione pending order
    if(currentState == STATE_MAIN_OPENING && pendingOrderTicket > 0) {
        CheckPendingMainOrderStatus();
        return;
    }
    
    if(!systemActive) return;
    
    // Update cooldown status
    if(EnableCooldown && cooldownActive) {
        if(TimeCurrent() >= cooldownEndTime) {
            cooldownActive = false;
            if(DetailedLogging) {
                Print("‚è±Ô∏è Cooldown ", cooldownType, " terminato");
            }
        }
    }
    
    UpdateSystemMetrics();
    
    // Aggiorna stato ordini pending grid
    if(GridOrderType == GRID_PENDING && gridActive) {
        CheckPendingOrdersStatus();
    }
    
    switch(currentState) {
        case STATE_MAIN_OPEN:
            MonitorMainPosition();
            
            if(EnableTrailingGrid && !cooldownActive) {
                UpdateTrailingGrid();
            }
            
            CheckGridActivation();
            CheckMainTakeProfit();
            break;
            
        case STATE_GRID_ACTIVE:
            MonitorMainPosition();
            
            if(EnableTrailingGrid && !cooldownActive) {
                UpdateTrailingGrid();
            }
            
            CheckNewGridLevel();
            CheckGridClosures();
            CheckMainTakeProfit();
            break;
    }
    
    if(EnableEmergencyStop) {
        CheckEmergencyStop();
    }
    
    UpdateDashboard();
}

//+------------------------------------------------------------------+
//| Chart event handler                                               |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam) {
    if(id == CHARTEVENT_OBJECT_CLICK) {
        HandleButtonClick(sparam);
    }
    
    if(id == CHARTEVENT_OBJECT_DRAG) {
        HandleObjectDrag(sparam);
    }
}

//+------------------------------------------------------------------+
//| Button click handler - DUAL CONTROL                              |
//+------------------------------------------------------------------+
void HandleButtonClick(string clickedObject) {
    // BUY BUTTONS
    if(clickedObject == "BTN_BUY_MARKET") {
        if(currentState == STATE_IDLE) {
            Print("üü¢ BUY MARKET richiesto");
            InitializeSystem(LONG, "MARKET");
        }
        ObjectSetInteger(0, clickedObject, OBJPROP_STATE, false);
        ChartRedraw();
    }
    
    if(clickedObject == "BTN_BUY_LIMIT") {
        if(currentState == STATE_IDLE) {
            Print("üü¢ BUY LIMIT richiesto");
            InitializeSystem(LONG, "LIMIT");
        }
        ObjectSetInteger(0, clickedObject, OBJPROP_STATE, false);
        ChartRedraw();
    }
    
    if(clickedObject == "BTN_BUY_STOP") {
        if(currentState == STATE_IDLE) {
            Print("üü¢ BUY STOP richiesto");
            InitializeSystem(LONG, "STOP");
        }
        ObjectSetInteger(0, clickedObject, OBJPROP_STATE, false);
        ChartRedraw();
    }
    
    // SELL BUTTONS
    if(clickedObject == "BTN_SELL_MARKET") {
        if(currentState == STATE_IDLE) {
            Print("üî¥ SELL MARKET richiesto");
            InitializeSystem(SHORT, "MARKET");
        }
        ObjectSetInteger(0, clickedObject, OBJPROP_STATE, false);
        ChartRedraw();
    }
    
    if(clickedObject == "BTN_SELL_LIMIT") {
        if(currentState == STATE_IDLE) {
            Print("üî¥ SELL LIMIT richiesto");
            InitializeSystem(SHORT, "LIMIT");
        }
        ObjectSetInteger(0, clickedObject, OBJPROP_STATE, false);
        ChartRedraw();
    }
    
    if(clickedObject == "BTN_SELL_STOP") {
        if(currentState == STATE_IDLE) {
            Print("üî¥ SELL STOP richiesto");
            InitializeSystem(SHORT, "STOP");
        }
        ObjectSetInteger(0, clickedObject, OBJPROP_STATE, false);
        ChartRedraw();
    }
    
    // CLOSE ALL
    if(clickedObject == "BTN_CLOSE_ALL") {
        if(systemActive) {
            CloseEntireSystem("User Manual Close");
        }
        ObjectSetInteger(0, clickedObject, OBJPROP_STATE, false);
        ChartRedraw();
    }
}

//+------------------------------------------------------------------+
//| Object drag handler                                               |
//+------------------------------------------------------------------+
void HandleObjectDrag(string draggedObj) {
    if(StringFind(draggedObj, "TP_LINE") >= 0) {
        double newPrice = ObjectGetDouble(0, draggedObj, OBJPROP_PRICE, 0);
        
        if(draggedObj == "GRID_TP_LINE") {
            double oldTP = currentGridTP;
            currentGridTP = MathAbs(newPrice - mainOpenPrice);
            UpdateGridTakeProfits(currentGridTP);
            Print("üìä Grid TP: ", oldTP/_Point/10, " ‚Üí ", currentGridTP/_Point/10, " pips");
        }
        
        if(draggedObj == "MAIN_TP_LINE") {
            mainTakeProfit = newPrice;
            UpdateMainTakeProfit(newPrice);
        }
        
        ChartRedraw();
    }
}

//+------------------------------------------------------------------+
//| System initialization - DUAL CONTROL                             |
//+------------------------------------------------------------------+
void InitializeSystem(ENUM_DIRECTION direction, string orderType) {
    if(!ValidateSystemStart()) return;
    
    Print("‚ïê‚ïê‚ïê INIZIALIZZAZIONE SISTEMA v1.3 FINAL ‚ïê‚ïê‚ïê");
    Print("üìä Direction: ", EnumToString(direction));
    Print("üìç Order Type: ", orderType);
    
    currentState = STATE_MAIN_OPENING;
    mainDirection = direction;
    pendingDirection = direction;
    pendingOrderType = orderType;
    
    double entryPrice = 0;
    // Inizializzazione con valore default per evitare warning compilazione
    ENUM_ORDER_TYPE mtOrderType = direction == LONG ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
    
    double currentPrice = direction == LONG ? 
                         SymbolInfoDouble(_Symbol, SYMBOL_ASK) :
                         SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // Determina prezzo entry e tipo ordine MT5
    if(orderType == "MARKET") {
        entryPrice = currentPrice;
        mtOrderType = direction == LONG ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
        Print("üìç MARKET @ ", entryPrice);
    }
    else if(orderType == "LIMIT") {
        double offset = LimitOffsetPips * _Point * 10;
        
        if(direction == LONG) {
            entryPrice = currentPrice - offset;  // BUY LIMIT sotto prezzo
            mtOrderType = ORDER_TYPE_BUY_LIMIT;
        } else {
            entryPrice = currentPrice + offset;  // SELL LIMIT sopra prezzo
            mtOrderType = ORDER_TYPE_SELL_LIMIT;
        }
        Print("üìç LIMIT @ ", entryPrice, " (offset ", LimitOffsetPips, " pips)");
    }
    else if(orderType == "STOP") {
        double offset = StopOffsetPips * _Point * 10;
        
        if(direction == LONG) {
            entryPrice = currentPrice + offset;  // BUY STOP sopra prezzo
            mtOrderType = ORDER_TYPE_BUY_STOP;
        } else {
            entryPrice = currentPrice - offset;  // SELL STOP sotto prezzo
            mtOrderType = ORDER_TYPE_SELL_STOP;
        }
        Print("üìç STOP @ ", entryPrice, " (offset ", StopOffsetPips, " pips)");
    }
    
    mainTakeProfit = CalculateMainTP(entryPrice, direction);
    
    bool result = false;
    
    // Ordini PENDING (LIMIT o STOP)
    if(mtOrderType == ORDER_TYPE_BUY_LIMIT || mtOrderType == ORDER_TYPE_SELL_LIMIT ||
       mtOrderType == ORDER_TYPE_BUY_STOP || mtOrderType == ORDER_TYPE_SELL_STOP) {
        
        result = trade.OrderOpen(_Symbol, mtOrderType, MainLotSize, 0, entryPrice, 
                                0, mainTakeProfit, ORDER_TIME_GTC, 0, "YOU-TRADE-MAIN");
        
        if(result) {
            pendingOrderTicket = trade.ResultOrder();
            pendingOrderTime = TimeCurrent();
            pendingRetryCount = 0;
            Print("‚úÖ Pending order piazzato: #", pendingOrderTicket);
        }
    }
    // Ordini MARKET
    else {
        result = trade.PositionOpen(_Symbol, mtOrderType, MainLotSize, entryPrice, 
                                   0, mainTakeProfit, "YOU-TRADE-MAIN");
        
        if(result) {
            CompleteSystemActivation(entryPrice);
        }
    }
    
    if(!result) {
        Alert("‚ùå Errore apertura: ", trade.ResultRetcodeDescription());
        currentState = STATE_ERROR;
    }
}

//+------------------------------------------------------------------+
//| Check pending main order status                                  |
//+------------------------------------------------------------------+
void CheckPendingMainOrderStatus() {
    // Check se ordine eseguito
    if(PositionSelectByTicket(pendingOrderTicket)) {
        double fillPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        Print("‚úÖ Pending order ESEGUITO @ ", fillPrice);
        CompleteSystemActivation(fillPrice);
        return;
    }
    
    // Check se ordine ancora pending
    if(OrderSelect(pendingOrderTicket)) {
        // Timeout check
        if(LimitTimeoutSeconds > 0) {
            int elapsed = (int)(TimeCurrent() - pendingOrderTime);
            
            if(elapsed >= LimitTimeoutSeconds) {
                Print("‚è±Ô∏è Pending timeout (", elapsed, "s)");
                trade.OrderDelete(pendingOrderTicket);
                
                if(AutoRetryLimit && pendingRetryCount < MaxLimitRetries) {
                    pendingRetryCount++;
                    Print("üîÑ Retry ", pendingRetryCount, "/", MaxLimitRetries);
                    pendingOrderTicket = 0;
                    InitializeSystem(pendingDirection, pendingOrderType);
                } else {
                    Alert("‚ö†Ô∏è Pending non eseguito dopo ", MaxLimitRetries, " tentativi");
                    currentState = STATE_IDLE;
                    pendingOrderTicket = 0;
                }
            }
        }
        return;
    }
    
    // Ordine cancellato/rifiutato
    Print("‚ö†Ô∏è Pending order perso/cancellato");
    currentState = STATE_IDLE;
    pendingOrderTicket = 0;
}

//+------------------------------------------------------------------+
//| Complete system activation                                        |
//+------------------------------------------------------------------+
void CompleteSystemActivation(double fillPrice) {
    mainTicket = PositionGetInteger(POSITION_TICKET);
    mainOpenPrice = fillPrice;
    systemActive = true;
    systemStartTime = TimeCurrent();
    currentState = STATE_MAIN_OPEN;
    pendingOrderTicket = 0;
    
    priceTimesSizeSummation = mainOpenPrice * MainLotSize;
    totalLotSizeSummation = MainLotSize;
    
    currentGridTP = GridTakeProfitPips * _Point * 10;
    trailedActivationPrice = 0;
    lastTrailedPrice = 0;
    trailingActive = false;
    
    DrawMainPositionLine();
    DrawTakeProfitLines();
    
    // Piazza grid pending se GRID_PENDING mode
    if(GridOrderType == GRID_PENDING) {
        PlaceInitialGridPendingOrders();
    } else {
        DrawPredictedGridLevels();
    }
    
    Print("‚úÖ SISTEMA ATTIVO v1.3 FINAL");
    Print("üìä Main ", EnumToString(mainDirection), " @ ", mainOpenPrice);
    Print("üéØ TP: ", mainTakeProfit);
    
    if(EnableAlerts) {
        Alert("‚úÖ YOU TRADE v1.3 - ", EnumToString(mainDirection), " Attivato!");
    }
}

//+------------------------------------------------------------------+
//| Place initial grid pending orders                                |
//+------------------------------------------------------------------+
void PlaceInitialGridPendingOrders() {
    Print("‚ïê‚ïê‚ïê PIAZZAMENTO GRID PENDING ORDERS ‚ïê‚ïê‚ïê");
    
    double activationBase = mainOpenPrice + (mainDirection == LONG ? 
                           -(GridActivationPips * _Point * 10) : 
                           (GridActivationPips * _Point * 10));
    
    for(int i = 1; i <= MaxGridLevels; i++) {
        double levelPrice = 0;
        if(mainDirection == LONG) {
            levelPrice = activationBase - ((i-1) * GridSpacing * _Point * 10);
        } else {
            levelPrice = activationBase + ((i-1) * GridSpacing * _Point * 10);
        }
        
        PlaceGridPendingOrder(i, levelPrice);
    }
    
    Print("‚úÖ ", MaxGridLevels, " ordini pending piazzati");
    pendingOrdersCount = MaxGridLevels;
    
    if(EnableAlerts) {
        Alert("üìä Grid Pending: ", MaxGridLevels, " ordini pronti (ZERO SPREAD!)");
    }
}

//+------------------------------------------------------------------+
//| Place single grid pending order                                  |
//+------------------------------------------------------------------+
void PlaceGridPendingOrder(int level, double price) {
    ENUM_ORDER_TYPE orderType = mainDirection == LONG ? ORDER_TYPE_SELL_STOP : ORDER_TYPE_BUY_STOP;
    
    double lotSize = CalculateGridLotSize(level);
    double stopLoss = (level == 1) ? CalculateGridStopLoss(price, orderType) : 0;
    double takeProfit = CalculateGridTP(price, orderType);
    
    string comment = "YOU-GRID-PENDING-L" + IntegerToString(level);
    
    if(trade.OrderOpen(_Symbol, orderType, lotSize, 0, price, stopLoss, takeProfit, 
                      ORDER_TIME_GTC, 0, comment)) {
        ulong ticket = trade.ResultOrder();
        gridPendingTickets[level-1] = ticket;
        gridOpenPrices[level-1] = price;
        gridLotSizes[level-1] = lotSize;
        gridTakeProfits[level-1] = takeProfit;
        gridStopLosses[level-1] = stopLoss;
        gridIsFilled[level-1] = false;
        
        DrawGridPendingLevel(level, price, takeProfit, stopLoss);
        
        if(DetailedLogging) {
            Print("‚úÖ Grid L", level, " PENDING @ ", price, " | Lot: ", lotSize);
        }
    } else {
        Print("‚ùå Errore piazzamento pending L", level, ": ", trade.ResultRetcodeDescription());
    }
}

//+------------------------------------------------------------------+
//| Check pending orders status                                      |
//+------------------------------------------------------------------+
void CheckPendingOrdersStatus() {
    pendingOrdersCount = 0;
    filledOrdersCount = 0;
    
    for(int i = 0; i < MaxGridLevels; i++) {
        if(gridPendingTickets[i] == 0) continue;
        
        // Check se √® diventato position
        if(PositionSelectByTicket(gridPendingTickets[i])) {
            if(!gridIsFilled[i]) {
                gridIsFilled[i] = true;
                gridTickets[i] = gridPendingTickets[i];
                gridOpenTimes[i] = TimeCurrent();
                totalGridOrders++;
                
                if(i == 0) {
                    currentGridLevel = MathMax(currentGridLevel, 1);
                    gridActive = true;
                    currentState = STATE_GRID_ACTIVE;
                } else {
                    currentGridLevel = MathMax(currentGridLevel, i+1);
                }
                
                priceTimesSizeSummation += gridOpenPrices[i] * gridLotSizes[i];
                totalLotSizeSummation += gridLotSizes[i];
                
                UpdateGridLevelVisual(i+1, true);
                
                Print("üí∞ Grid L", i+1, " FILLED @ ", gridOpenPrices[i]);
                
                if(EnableAlerts) {
                    Alert("üí∞ Grid Level ", i+1, " attivato!");
                }
                
                if(EnableCooldown) {
                    ActivateCooldown("DOWN", CooldownDownSeconds);
                }
            }
            filledOrdersCount++;
        }
        // Check se √® ancora pending
        else if(OrderSelect(gridPendingTickets[i])) {
            pendingOrdersCount++;
        }
    }
}

//+------------------------------------------------------------------+
//| Activate cooldown                                                 |
//+------------------------------------------------------------------+
void ActivateCooldown(string type, int seconds) {
    cooldownActive = true;
    cooldownEndTime = TimeCurrent() + seconds;
    cooldownType = type;
    
    if(DetailedLogging) {
        Print("‚è±Ô∏è Cooldown ", type, " attivato per ", seconds, "s");
    }
}

//+------------------------------------------------------------------+
//| Validation pre-start                                              |
//+------------------------------------------------------------------+
bool ValidateSystemStart() {
    if(MainLotSize <= 0 || GridSpacing <= 0 || MainTakeProfitPips <= 0) {
        Alert("‚ö†Ô∏è Parametri non validi");
        return false;
    }
    
    if(!TerminalInfoInteger(TERMINAL_CONNECTED)) {
        Alert("‚ö†Ô∏è Nessuna connessione broker");
        return false;
    }
    
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    if(LotSizeMode == STANDARD && StandardLotSize < minLot) {
        Alert("‚ö†Ô∏è Standard lot < minimo broker: ", minLot);
        return false;
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| Monitor main position                                             |
//+------------------------------------------------------------------+
void MonitorMainPosition() {
    if(!PositionSelectByTicket(mainTicket)) {
        if(mainCurrentProfit > 0) {
            CloseEntireSystem("Main TP Reached");
        } else {
            CloseEntireSystem("Main Position Lost");
        }
    }
}

//+------------------------------------------------------------------+
//| Update trailing grid                                              |
//+------------------------------------------------------------------+
void UpdateTrailingGrid() {
    double currentPrice = mainDirection == LONG ? 
                         SymbolInfoDouble(_Symbol, SYMBOL_BID) :
                         SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    
    double profitPips = 0;
    if(mainDirection == LONG) {
        profitPips = (currentPrice - mainOpenPrice) / _Point / 10;
    } else {
        profitPips = (mainOpenPrice - currentPrice) / _Point / 10;
    }
    
    if(profitPips >= TrailingStartPips) {
        if(!trailingActive) {
            trailingActive = true;
            Print("üöÄ TRAILING GRID ATTIVATO @ +", profitPips, " pips");
            
            if(EnableAlerts) {
                Alert("üöÄ Trailing Grid attivo!");
            }
        }
        
        double newActivation = 0;
        
        if(mainDirection == LONG) {
            newActivation = currentPrice - (TrailingMinDistance * _Point * 10);
            
            if(!TrailToBreakeven && newActivation > mainOpenPrice) {
                newActivation = mainOpenPrice - (GridActivationPips * _Point * 10);
            }
        } else {
            newActivation = currentPrice + (TrailingMinDistance * _Point * 10);
            
            if(!TrailToBreakeven && newActivation < mainOpenPrice) {
                newActivation = mainOpenPrice + (GridActivationPips * _Point * 10);
            }
        }
        
        double initialActivation = mainOpenPrice + (mainDirection == LONG ? 
                                   -(GridActivationPips * _Point * 10) : 
                                   (GridActivationPips * _Point * 10));
        
        if(trailedActivationPrice == 0) {
            trailedActivationPrice = initialActivation;
        }
        
        double improvement = MathAbs(newActivation - trailedActivationPrice) / _Point / 10;
        
        if(improvement >= TrailingStepPips) {
            double oldAct = trailedActivationPrice;
            trailedActivationPrice = newActivation;
            lastTrailedPrice = currentPrice;
            
            if(GridOrderType == GRID_PENDING) {
                ShiftGridPendingOrders(newActivation);
            } else {
                UpdatePredictedGridLevels(newActivation);
            }
            
            totalTrailingShifts++;
            
            Print("üìà TRAILING: ", oldAct, " ‚Üí ", newActivation, " (+", improvement, " pips)");
            
            if(EnableCooldown) {
                ActivateCooldown("UP", CooldownUpSeconds);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Shift grid pending orders                                         |
//+------------------------------------------------------------------+
void ShiftGridPendingOrders(double newActivation) {
    Print("üîÑ SHIFT GRID PENDING ORDERS ‚Üí ", newActivation);
    
    int canceledCount = 0;
    
    for(int i = 0; i < MaxGridLevels; i++) {
        if(gridPendingTickets[i] == 0) continue;
        if(gridIsFilled[i]) continue;
        
        if(OrderSelect(gridPendingTickets[i])) {
            if(trade.OrderDelete(gridPendingTickets[i])) {
                gridPendingTickets[i] = 0;
                canceledCount++;
                totalPendingCanceled++;
                RemoveGridLevelVisual(i+1);
            }
        }
    }
    
    if(DetailedLogging) {
        Print("‚úÖ Cancellati ", canceledCount, " ordini pending");
    }
    
    for(int i = 1; i <= MaxGridLevels; i++) {
        if(gridIsFilled[i-1]) continue;
        
        double levelPrice = 0;
        if(mainDirection == LONG) {
            levelPrice = newActivation - ((i-1) * GridSpacing * _Point * 10);
        } else {
            levelPrice = newActivation + ((i-1) * GridSpacing * _Point * 10);
        }
        
        PlaceGridPendingOrder(i, levelPrice);
    }
    
    pendingOrdersCount = MaxGridLevels - filledOrdersCount;
    Print("‚úÖ Ripiazzati ", pendingOrdersCount, " ordini pending");
}

//+------------------------------------------------------------------+
//| Check grid activation (MARKET mode)                              |
//+------------------------------------------------------------------+
void CheckGridActivation() {
    if(gridActive) return;
    if(GridOrderType == GRID_PENDING) return;
    
    double activationThreshold = trailingActive && trailedActivationPrice != 0 ? 
                                 trailedActivationPrice :
                                 (mainOpenPrice + (mainDirection == LONG ? 
                                  -(GridActivationPips * _Point * 10) : 
                                  (GridActivationPips * _Point * 10)));
    
    double currentPrice = mainDirection == LONG ? 
                         SymbolInfoDouble(_Symbol, SYMBOL_BID) :
                         SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    
    bool shouldActivate = false;
    if(mainDirection == LONG && currentPrice <= activationThreshold) {
        shouldActivate = true;
    } else if(mainDirection == SHORT && currentPrice >= activationThreshold) {
        shouldActivate = true;
    }
    
    if(shouldActivate) {
        ActivateGrid(currentPrice);
    }
}

//+------------------------------------------------------------------+
//| Activate grid                                                     |
//+------------------------------------------------------------------+
void ActivateGrid(double currentPrice) {
    Print("üîÑ GRID ATTIVATO @ ", currentPrice);
    gridActive = true;
    currentState = STATE_GRID_ACTIVE;
    OpenFirstGridLevel(currentPrice);
    
    if(EnableCooldown) {
        ActivateCooldown("DOWN", CooldownDownSeconds);
    }
}

//+------------------------------------------------------------------+
//| Open first grid level                                            |
//+------------------------------------------------------------------+
void OpenFirstGridLevel(double price) {
    ENUM_ORDER_TYPE gridType = mainDirection == LONG ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
    
    double lotSize = CalculateGridLotSize(1);
    double stopLoss = CalculateGridStopLoss(price, gridType);
    double takeProfit = CalculateGridTP(price, gridType);
    
    if(trade.PositionOpen(_Symbol, gridType, lotSize, price, stopLoss, takeProfit, 
                         "YOU-TRADE-GRID-1")) {
        gridTickets[0] = trade.ResultOrder();
        gridOpenPrices[0] = price;
        gridLotSizes[0] = lotSize;
        gridTakeProfits[0] = takeProfit;
        gridStopLosses[0] = stopLoss;
        gridIsFilled[0] = true;
        gridOpenTimes[0] = TimeCurrent();
        currentGridLevel = 1;
        totalGridOrders++;
        filledOrdersCount++;
        
        priceTimesSizeSummation += price * lotSize;
        totalLotSizeSummation += lotSize;
        
        DrawGridFilledLevel(1, price, takeProfit, stopLoss);
    }
}

//+------------------------------------------------------------------+
//| Check new grid level                                             |
//+------------------------------------------------------------------+
void CheckNewGridLevel() {
    if(GridOrderType == GRID_PENDING) return;
    if(currentGridLevel >= MaxGridLevels) return;
    if(cooldownActive) return;
    
    double currentPrice = mainDirection == LONG ? 
                         SymbolInfoDouble(_Symbol, SYMBOL_ASK) :
                         SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    double lastGridPrice = gridOpenPrices[currentGridLevel - 1];
    double distance = MathAbs(currentPrice - lastGridPrice) / _Point / 10;
    
    if(distance >= GridSpacing) {
        bool shouldOpen = false;
        if(mainDirection == LONG && currentPrice < lastGridPrice) {
            shouldOpen = true;
        } else if(mainDirection == SHORT && currentPrice > lastGridPrice) {
            shouldOpen = true;
        }
        
        if(shouldOpen) {
            OpenNextGridLevel(currentPrice);
        }
    }
}

//+------------------------------------------------------------------+
//| Open next grid level                                             |
//+------------------------------------------------------------------+
void OpenNextGridLevel(double price) {
    int level = currentGridLevel + 1;
    double lotSize = CalculateGridLotSize(level);
    ENUM_ORDER_TYPE gridType = mainDirection == LONG ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
    double stopLoss = 0;
    double takeProfit = CalculateGridTP(price, gridType);
    
    if(trade.PositionOpen(_Symbol, gridType, lotSize, price, stopLoss, takeProfit, 
                         "YOU-TRADE-GRID-" + IntegerToString(level))) {
        gridTickets[level-1] = trade.ResultOrder();
        gridOpenPrices[level-1] = price;
        gridLotSizes[level-1] = lotSize;
        gridTakeProfits[level-1] = takeProfit;
        gridStopLosses[level-1] = stopLoss;
        gridIsFilled[level-1] = true;
        gridOpenTimes[level-1] = TimeCurrent();
        currentGridLevel = level;
        totalGridOrders++;
        filledOrdersCount++;
        
        priceTimesSizeSummation += price * lotSize;
        totalLotSizeSummation += lotSize;
        
        DrawGridFilledLevel(level, price, takeProfit, stopLoss);
        
        if(EnableCooldown) {
            ActivateCooldown("DOWN", CooldownDownSeconds);
        }
    }
}

//+------------------------------------------------------------------+
//| Calculate grid lot size                                           |
//+------------------------------------------------------------------+
double CalculateGridLotSize(int level) {
    double lotSize = 0;
    
    if(LotSizeMode == STANDARD) {
        lotSize = StandardLotSize;
    } else {
        lotSize = ProgressionStartLot + ((level - 1) * ProgressionIncrement);
        if(lotSize > ProgressionMaxLot) {
            lotSize = ProgressionMaxLot;
        }
    }
    
    return NormalizeLotSize(lotSize);
}

//+------------------------------------------------------------------+
//| Calculate grid stop loss                                          |
//+------------------------------------------------------------------+
double CalculateGridStopLoss(double entryPrice, ENUM_ORDER_TYPE orderType) {
    double slDistance = FirstGridStopLoss * _Point * 10;
    
    double sl = 0;
    if(orderType == ORDER_TYPE_BUY || orderType == ORDER_TYPE_BUY_STOP) {
        sl = entryPrice - slDistance;
    } else {
        sl = entryPrice + slDistance;
    }
    
    return NormalizeDouble(sl, _Digits);
}

//+------------------------------------------------------------------+
//| Calculate grid TP                                                 |
//+------------------------------------------------------------------+
double CalculateGridTP(double entryPrice, ENUM_ORDER_TYPE orderType) {
    double tpDistance = currentGridTP;
    
    double tp = 0;
    if(orderType == ORDER_TYPE_BUY || orderType == ORDER_TYPE_BUY_STOP) {
        tp = entryPrice + tpDistance;
    } else {
        tp = entryPrice - tpDistance;
    }
    
    return NormalizeDouble(tp, _Digits);
}

//+------------------------------------------------------------------+
//| Calculate main TP  si                                               |
//+------------------------------------------------------------------+
double CalculateMainTP(double entryPrice, ENUM_DIRECTION direction) {
    double tpDistance = MainTakeProfitPips * _Point * 10;
    
    double tp = 0;
    if(direction == LONG) {
        tp = entryPrice + tpDistance;
    } else {
        tp = entryPrice - tpDistance;
    }
    
    return NormalizeDouble(tp, _Digits);
}

//+------------------------------------------------------------------+
//| Check grid closures                                               |
//+------------------------------------------------------------------+
void CheckGridClosures() {
    for(int i = 0; i < currentGridLevel; i++) {
        if(gridTickets[i] == 0) continue;
        if(!gridIsFilled[i]) continue;
        
        if(!PositionSelectByTicket(gridTickets[i])) {
            Print("üí∞ Grid L", i+1, " chiuso (TP)");
            totalGridCycles++;
            gridTickets[i] = 0;
            filledOrdersCount--;
        }
    }
}

//+------------------------------------------------------------------+
//| Check main TP                                                     |
//+------------------------------------------------------------------+
void CheckMainTakeProfit() {
    double currentPrice = mainDirection == LONG ? 
                         SymbolInfoDouble(_Symbol, SYMBOL_BID) :
                         SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    
    bool tpHit = false;
    if(mainDirection == LONG && currentPrice >= mainTakeProfit) {
        tpHit = true;
    } else if(mainDirection == SHORT && currentPrice <= mainTakeProfit) {
        tpHit = true;
    }
    
    if(tpHit) {
        Print("üéØ Main TP @ ", currentPrice);
        
        if(EnableAlerts) {
            Alert("üéØ TAKE PROFIT RAGGIUNTO!");
        }
        
        CloseEntireSystem("Main TP Reached");
    }
}

//+------------------------------------------------------------------+
//| Update grid TPs                                                   |
//+------------------------------------------------------------------+
void UpdateGridTakeProfits(double newTPDistance) {
    for(int i = 0; i < MaxGridLevels; i++) {
        if(gridPendingTickets[i] == 0) continue;
        
        if(!gridIsFilled[i] && OrderSelect(gridPendingTickets[i])) {
            double openPrice = gridOpenPrices[i];
            ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
            
            double tp = 0;
            if(orderType == ORDER_TYPE_BUY_STOP) {
                tp = openPrice + newTPDistance;
            } else {
                tp = openPrice - newTPDistance;
            }
            
            trade.OrderModify(gridPendingTickets[i], openPrice, 0, tp, ORDER_TIME_GTC, 0);
            gridTakeProfits[i] = tp;
        }
        
        if(gridIsFilled[i] && gridTickets[i] > 0 && PositionSelectByTicket(gridTickets[i])) {
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            ENUM_ORDER_TYPE posType = (ENUM_ORDER_TYPE)PositionGetInteger(POSITION_TYPE);
            
            double tp = 0;
            if(posType == ORDER_TYPE_BUY) {
                tp = openPrice + newTPDistance;
            } else {
                tp = openPrice - newTPDistance;
            }
            
            trade.PositionModify(gridTickets[i], 0, tp);
            gridTakeProfits[i] = tp;
        }
    }
}

//+------------------------------------------------------------------+
//| Update main TP                                                    |
//+------------------------------------------------------------------+
void UpdateMainTakeProfit(double newTP) {
    if(mainTicket > 0 && PositionSelectByTicket(mainTicket)) {
        trade.PositionModify(mainTicket, 0, newTP);
        mainTakeProfit = newTP;
    }
}

//+------------------------------------------------------------------+
//| Check emergency stop                                              |
//+------------------------------------------------------------------+
void CheckEmergencyStop() {
    if(currentDrawdown >= EmergencyStopPercent) {
        Print("üö® EMERGENCY STOP - DD: ", currentDrawdown, "%");
        
        if(EnableAlerts) {
            Alert("üö® EMERGENCY STOP ATTIVATO!");
        }
        
        CloseEntireSystem("EMERGENCY STOP");
    }
}

//+------------------------------------------------------------------+
//| Close entire system                                               |
//+------------------------------------------------------------------+
void CloseEntireSystem(string reason) {
    Print("üî¥ CHIUSURA SISTEMA: ", reason);
    currentState = STATE_CLOSING;
    
    int closedPositions = 0;
    int canceledOrders = 0;
    
    for(int i = 0; i < MaxGridLevels; i++) {
        if(gridPendingTickets[i] == 0) continue;
        if(gridIsFilled[i]) continue;
        
        if(OrderSelect(gridPendingTickets[i])) {
            if(trade.OrderDelete(gridPendingTickets[i])) {
                canceledOrders++;
                totalPendingCanceled++;
            }
        }
    }
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        if(PositionSelectByTicket(PositionGetTicket(i))) {
            if(PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
                if(PositionGetString(POSITION_SYMBOL) == _Symbol) {
                    if(trade.PositionClose(PositionGetTicket(i))) {
                        closedPositions++;
                    }
                }
            }
        }
    }
    
    SaveSessionStatistics(reason);
    
    Print("‚ïê‚ïê‚ïê REPORT FINALE v1.3 ‚ïê‚ïê‚ïê");
    Print("üìä Posizioni chiuse: ", closedPositions);
    Print("üìä Ordini cancellati: ", canceledOrders);
    Print("üí∞ Profit totale: $", NormalizeDouble(totalSystemProfit, 2));
    Print("üìâ Max DD: ", NormalizeDouble(maxDrawdown, 2), "%");
    
    if(EnableAlerts) {
        Alert("üî¥ Sistema chiuso: ", reason);
    }
    
    ResetSystem();
}

//+------------------------------------------------------------------+
//| Reset system                                                      |
//+------------------------------------------------------------------+
void ResetSystem() {
    systemActive = false;
    gridActive = false;
    currentState = STATE_IDLE;
    pendingOrderTicket = 0;
    
    mainTicket = 0;
    mainOpenPrice = 0;
    mainCurrentProfit = 0;
    mainTakeProfit = 0;
    
    currentGridLevel = 0;
    totalGridProfit = 0;
    totalSystemProfit = 0;
    currentDrawdown = 0;
    maxDrawdown = 0;
    
    trailedActivationPrice = 0;
    lastTrailedPrice = 0;
    trailingActive = false;
    
    cooldownActive = false;
    cooldownEndTime = 0;
    cooldownType = "";
    
    pendingOrdersCount = 0;
    filledOrdersCount = 0;
    
    ArrayInitialize(gridTickets, 0);
    ArrayInitialize(gridPendingTickets, 0);
    ArrayInitialize(gridOpenPrices, 0);
    ArrayInitialize(gridLotSizes, 0);
    ArrayInitialize(gridTakeProfits, 0);
    ArrayInitialize(gridStopLosses, 0);
    ArrayInitialize(gridOpenTimes, 0);
    ArrayInitialize(gridIsFilled, false);
    
    priceTimesSizeSummation = 0;
    totalLotSizeSummation = 0;
    weightedAvgPrice = 0;
    
    totalGridCycles = 0;
    totalGridOrders = 0;
    totalTrailingShifts = 0;
    totalPendingCanceled = 0;
    
    RemoveGraphicalLines();
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Update system metrics                                             |
//+------------------------------------------------------------------+
void UpdateSystemMetrics() {
    mainCurrentProfit = 0;
    totalGridProfit = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        if(PositionSelectByTicket(PositionGetTicket(i))) {
            if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
            if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
            
            string comment = PositionGetString(POSITION_COMMENT);
            double profit = PositionGetDouble(POSITION_PROFIT);
            double swap = PositionGetDouble(POSITION_SWAP);
            double totalProfit = profit + swap;
            
            if(StringFind(comment, "MAIN") >= 0) {
                mainCurrentProfit = totalProfit;
            } else if(StringFind(comment, "GRID") >= 0) {
                totalGridProfit += totalProfit;
            }
        }
    }
    
    totalSystemProfit = mainCurrentProfit + totalGridProfit;
    
    double equity = AccountInfoDouble(ACCOUNT_EQUITY);
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    currentDrawdown = ((balance - equity) / balance) * 100;
    
    if(currentDrawdown > maxDrawdown) {
        maxDrawdown = currentDrawdown;
    }
    
    if(totalLotSizeSummation > 0) {
        weightedAvgPrice = priceTimesSizeSummation / totalLotSizeSummation;
    }
}

//+------------------------------------------------------------------+
//| Normalize lot size                                                |
//+------------------------------------------------------------------+
double NormalizeLotSize(double lot) {
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    
    lot = MathMax(lot, minLot);
    lot = MathMin(lot, maxLot);
    lot = MathRound(lot / lotStep) * lotStep;
    
    return NormalizeDouble(lot, 2);
}

//+------------------------------------------------------------------+
//| Save session statistics                                           |
//+------------------------------------------------------------------+
void SaveSessionStatistics(string reason) {
    int handle = FileOpen("YOU_TRADE_v1.3_Stats.csv", FILE_WRITE | FILE_READ | FILE_CSV | FILE_ANSI, ',');
    
    if(handle != INVALID_HANDLE) {
        FileSeek(handle, 0, SEEK_END);
        
        FileWrite(handle,
                 TimeToString(systemStartTime),
                 TimeToString(TimeCurrent()),
                 _Symbol,
                 EnumToString(mainDirection),
                 DoubleToString(MainLotSize, 2),
                 IntegerToString(currentGridLevel),
                 IntegerToString(totalGridCycles),
                 IntegerToString(totalGridOrders),
                 IntegerToString(totalTrailingShifts),
                 IntegerToString(totalPendingCanceled),
                 DoubleToString(totalSystemProfit, 2),
                 DoubleToString(maxDrawdown, 2),
                 GridOrderType == GRID_PENDING ? "PENDING" : "MARKET",
                 trailingActive ? "Trailing-ON" : "Trailing-OFF",
                 reason);
        
        FileClose(handle);
    }
}

//+------------------------------------------------------------------+
//| UI FUNCTIONS - DUAL DASHBOARD                                    |
//+------------------------------------------------------------------+

void CreateDashboard() {
    int x = 10, y = 30;
    int width = 320, height = 480;
    
    CreateRectangle("PANEL_BG", x, y, width, height, PanelBackColor);
    
    CreateLabel("LBL_TITLE", x + 10, y + 10, "YOU TRADE v1.3 - Dual Control", clrWhite, 11, "Arial Bold");
    
    y += 40;
    CreateLabel("LBL_STATUS", x + 10, y, "Status: IDLE", clrLime, 9);
    
    y += 25;
    CreateLabel("LBL_MAIN_TITLE", x + 10, y, "‚ïê‚ïê‚ïê MAIN POSITION ‚ïê‚ïê‚ïê", clrGold, 9, "Arial Bold");
    y += 20;
    CreateLabel("LBL_MAIN_INFO", x + 10, y, "Direction: - | Profit: -", PanelTextColor, 8);
    
    y += 30;
    CreateLabel("LBL_GRID_TITLE", x + 10, y, "‚ïê‚ïê‚ïê GRID HEDGING ‚ïê‚ïê‚ïê", clrOrange, 9, "Arial Bold");
    y += 20;
    CreateLabel("LBL_GRID_INFO", x + 10, y, "Levels: 0 | Cycles: 0", PanelTextColor, 8);
    y += 18;
    CreateLabel("LBL_GRID_PROFIT", x + 10, y, "Grid Profit: 0.00", PanelTextColor, 8);
    y += 18;
    CreateLabel("LBL_GRID_ORDERS", x + 10, y, "Pending: 0 | Filled: 0", PanelTextColor, 8);
    
    y += 30;
    CreateLabel("LBL_TRAIL_TITLE", x + 10, y, "‚ïê‚ïê‚ïê TRAILING ‚ïê‚ïê‚ïê", clrDodgerBlue, 9, "Arial Bold");
    y += 20;
    CreateLabel("LBL_TRAIL_INFO", x + 10, y, "Status: Inactive", PanelTextColor, 8);
    y += 18;
    CreateLabel("LBL_TRAIL_SHIFTS", x + 10, y, "Shifts: 0", PanelTextColor, 8);
    
    y += 30;
    CreateLabel("LBL_COOLDOWN_TITLE", x + 10, y, "‚ïê‚ïê‚ïê COOLDOWN ‚ïê‚ïê‚ïê", clrYellow, 9, "Arial Bold");
    y += 20;
    CreateLabel("LBL_COOLDOWN_INFO", x + 10, y, "Status: Inactive", PanelTextColor, 8);
    
    y += 30;
    CreateLabel("LBL_PERF_TITLE", x + 10, y, "‚ïê‚ïê‚ïê PERFORMANCE ‚ïê‚ïê‚ïê", clrDodgerBlue, 9, "Arial Bold");
    y += 20;
    CreateLabel("LBL_TOTAL_PROFIT", x + 10, y, "Total Profit: 0.00", PanelTextColor, 9);
    y += 18;
    CreateLabel("LBL_DRAWDOWN", x + 10, y, "Drawdown: 0.00%", PanelTextColor, 8);
    y += 18;
    CreateLabel("LBL_TIME", x + 10, y, "Time: 0h 0m", PanelTextColor, 8);
    
    ChartRedraw();
}

void CreateDualControlButtons() {
    int x = 10, y = 540;
    int btnWidth = 95;
    int btnHeight = 30;
    int spacing = 5;
    
    // Label BUY
    CreateLabel("LBL_BUY", x, y, "‚ïê‚ïê‚ïê BUY ‚ïê‚ïê‚ïê", clrLimeGreen, 9, "Arial Bold");
    y += 20;
    
    // Bottoni BUY
    CreateButton("BTN_BUY_MARKET", x, y, btnWidth, btnHeight, "MARKET", clrLimeGreen);
    CreateButton("BTN_BUY_LIMIT", x + btnWidth + spacing, y, btnWidth, btnHeight, "LIMIT", clrDodgerBlue);
    CreateButton("BTN_BUY_STOP", x + (btnWidth + spacing)*2, y, btnWidth, btnHeight, "STOP", clrGold);
    
    y += btnHeight + 15;
    
    // Label SELL
    CreateLabel("LBL_SELL", x, y, "‚ïê‚ïê‚ïê SELL ‚ïê‚ïê‚ïê", clrRed, 9, "Arial Bold");
    y += 20;
    
    // Bottoni SELL
    CreateButton("BTN_SELL_MARKET", x, y, btnWidth, btnHeight, "MARKET", clrRed);
    CreateButton("BTN_SELL_LIMIT", x + btnWidth + spacing, y, btnWidth, btnHeight, "LIMIT", clrOrangeRed);
    CreateButton("BTN_SELL_STOP", x + (btnWidth + spacing)*2, y, btnWidth, btnHeight, "STOP", clrDarkOrange);
    
    y += btnHeight + 15;
    
    // Bottone CLOSE ALL
    CreateButton("BTN_CLOSE_ALL", x, y, (btnWidth + spacing)*3 - spacing, btnHeight, "CLOSE ALL POSITIONS", clrMaroon);
    
    ChartRedraw();
}

void UpdateDashboard() {
    if(!systemActive) {
        ObjectSetString(0, "LBL_STATUS", OBJPROP_TEXT, "Status: IDLE");
        ObjectSetInteger(0, "LBL_STATUS", OBJPROP_COLOR, clrGray);
        return;
    }
    
    string status = EnumToString(currentState);
    color statusColor = currentState == STATE_MAIN_OPEN ? clrLime : clrYellow;
    ObjectSetString(0, "LBL_STATUS", OBJPROP_TEXT, "Status: " + status);
    ObjectSetInteger(0, "LBL_STATUS", OBJPROP_COLOR, statusColor);
    
    string mainText = StringFormat("%s | P: %.2f", 
                                   EnumToString(mainDirection),
                                   mainCurrentProfit);
    ObjectSetString(0, "LBL_MAIN_INFO", OBJPROP_TEXT, mainText);
    
    string gridText = StringFormat("L: %d/%d | C: %d | O: %d",
                                  currentGridLevel, MaxGridLevels, 
                                  totalGridCycles, totalGridOrders);
    ObjectSetString(0, "LBL_GRID_INFO", OBJPROP_TEXT, gridText);
    
    string gridProfitText = StringFormat("Grid: %.2f", totalGridProfit);
    color gridColor = totalGridProfit > 0 ? clrLime : (totalGridProfit < 0 ? clrRed : clrWhite);
    ObjectSetString(0, "LBL_GRID_PROFIT", OBJPROP_TEXT, gridProfitText);
    ObjectSetInteger(0, "LBL_GRID_PROFIT", OBJPROP_COLOR, gridColor);
    
    string ordersText = StringFormat("Pending: %d | Filled: %d", pendingOrdersCount, filledOrdersCount);
    ObjectSetString(0, "LBL_GRID_ORDERS", OBJPROP_TEXT, ordersText);
    
    string trailText = trailingActive ? StringFormat("ACTIVE (Shifts: %d)", totalTrailingShifts) : "Inactive";
    color trailColor = trailingActive ? clrLime : clrGray;
    ObjectSetString(0, "LBL_TRAIL_INFO", OBJPROP_TEXT, "Status: " + trailText);
    ObjectSetInteger(0, "LBL_TRAIL_INFO", OBJPROP_COLOR, trailColor);
    
    string shiftsText = StringFormat("Total Shifts: %d", totalTrailingShifts);
    ObjectSetString(0, "LBL_TRAIL_SHIFTS", OBJPROP_TEXT, shiftsText);
    
    string cooldownText = "Inactive";
    color cooldownColor = clrGray;
    if(cooldownActive) {
        int remaining = (int)(cooldownEndTime - TimeCurrent());
        cooldownText = StringFormat("%s: %ds", cooldownType, remaining);
        cooldownColor = clrYellow;
    }
    ObjectSetString(0, "LBL_COOLDOWN_INFO", OBJPROP_TEXT, "Status: " + cooldownText);
    ObjectSetInteger(0, "LBL_COOLDOWN_INFO", OBJPROP_COLOR, cooldownColor);
    
    string profitText = StringFormat("Total: %.2f", totalSystemProfit);
    color profitColor = totalSystemProfit > 0 ? clrLime : (totalSystemProfit < 0 ? clrRed : clrWhite);
    ObjectSetString(0, "LBL_TOTAL_PROFIT", OBJPROP_TEXT, profitText);
    ObjectSetInteger(0, "LBL_TOTAL_PROFIT", OBJPROP_COLOR, profitColor);
    
    string ddText = StringFormat("DD: %.2f%% (Max: %.2f%%)",
                                currentDrawdown, maxDrawdown);
    color ddColor = currentDrawdown < 10 ? clrLime : 
                   (currentDrawdown < 20 ? clrYellow : clrRed);
    ObjectSetString(0, "LBL_DRAWDOWN", OBJPROP_TEXT, ddText);
    ObjectSetInteger(0, "LBL_DRAWDOWN", OBJPROP_COLOR, ddColor);
    
    int seconds = (int)(TimeCurrent() - systemStartTime);
    int hours = seconds / 3600;
    int minutes = (seconds % 3600) / 60;
    string timeText = StringFormat("Time: %dh %dm", hours, minutes);
    ObjectSetString(0, "LBL_TIME", OBJPROP_TEXT, timeText);
}

void DrawMainPositionLine() {
    string name = "MAIN_POS_LINE";
    ObjectCreate(0, name, OBJ_HLINE, 0, 0, mainOpenPrice);
    ObjectSetInteger(0, name, OBJPROP_COLOR, MainLineColor);
    ObjectSetInteger(0, name, OBJPROP_WIDTH, 2);
    ObjectSetInteger(0, name, OBJPROP_STYLE, STYLE_SOLID);
    ObjectSetString(0, name, OBJPROP_TEXT, "Main " + EnumToString(mainDirection) + " @ " + DoubleToString(mainOpenPrice, _Digits));
    ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
}

void DrawTakeProfitLines() {
    string mainTP = "MAIN_TP_LINE";
    ObjectCreate(0, mainTP, OBJ_HLINE, 0, 0, mainTakeProfit);
    ObjectSetInteger(0, mainTP, OBJPROP_COLOR, TPLineColor);
    ObjectSetInteger(0, mainTP, OBJPROP_WIDTH, 2);
    ObjectSetInteger(0, mainTP, OBJPROP_STYLE, STYLE_DOT);
    ObjectSetString(0, mainTP, OBJPROP_TEXT, "Main TP @ " + DoubleToString(mainTakeProfit, _Digits));
    ObjectSetInteger(0, mainTP, OBJPROP_SELECTABLE, true);
    
    string gridTP = "GRID_TP_LINE";
    double exampleGridTP = mainOpenPrice + (mainDirection == LONG ? -currentGridTP : currentGridTP);
    ObjectCreate(0, gridTP, OBJ_HLINE, 0, 0, exampleGridTP);
    ObjectSetInteger(0, gridTP, OBJPROP_COLOR, clrOrange);
    ObjectSetInteger(0, gridTP, OBJPROP_WIDTH, 1);
    ObjectSetInteger(0, gridTP, OBJPROP_STYLE, STYLE_DASHDOT);
    ObjectSetString(0, gridTP, OBJPROP_TEXT, "Grid TP (Drag to modify)");
    ObjectSetInteger(0, gridTP, OBJPROP_SELECTABLE, true);
}

void DrawPredictedGridLevels() {
    double activationBase = trailedActivationPrice != 0 ? trailedActivationPrice :
                           (mainOpenPrice + (mainDirection == LONG ? 
                            -(GridActivationPips * _Point * 10) : 
                            (GridActivationPips * _Point * 10)));
    
    for(int i = 1; i <= MaxGridLevels; i++) {
        double levelPrice = 0;
        if(mainDirection == LONG) {
            levelPrice = activationBase - ((i-1) * GridSpacing * _Point * 10);
        } else {
            levelPrice = activationBase + ((i-1) * GridSpacing * _Point * 10);
        }
        
        string name = "PRED_GRID_" + IntegerToString(i);
        ObjectCreate(0, name, OBJ_HLINE, 0, 0, levelPrice);
        ObjectSetInteger(0, name, OBJPROP_COLOR, GridLineColor);
        ObjectSetInteger(0, name, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, name, OBJPROP_STYLE, STYLE_DASH);
        ObjectSetString(0, name, OBJPROP_TEXT, "Predicted L" + IntegerToString(i));
        ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
    }
}

void UpdatePredictedGridLevels(double newActivation) {
    for(int i = 1; i <= MaxGridLevels; i++) {
        double levelPrice = 0;
        if(mainDirection == LONG) {
            levelPrice = newActivation - ((i-1) * GridSpacing * _Point * 10);
        } else {
            levelPrice = newActivation + ((i-1) * GridSpacing * _Point * 10);
        }
        
        string name = "PRED_GRID_" + IntegerToString(i);
        ObjectMove(0, name, 0, 0, levelPrice);
    }
}

void DrawGridPendingLevel(int level, double price, double tp, double sl) {
    string baseName = "GRID_L" + IntegerToString(level);
    
    string lineName = baseName + "_LINE";
    ObjectCreate(0, lineName, OBJ_HLINE, 0, 0, price);
    ObjectSetInteger(0, lineName, OBJPROP_COLOR, GridPendingColor);
    ObjectSetInteger(0, lineName, OBJPROP_WIDTH, 2);
    ObjectSetInteger(0, lineName, OBJPROP_STYLE, STYLE_DASHDOT);
    ObjectSetString(0, lineName, OBJPROP_TEXT, "PENDING L" + IntegerToString(level) + " @ " + DoubleToString(price, _Digits));
    ObjectSetInteger(0, lineName, OBJPROP_SELECTABLE, false);
    
    string tpName = baseName + "_TP";
    ObjectCreate(0, tpName, OBJ_ARROW_RIGHT_PRICE, 0, TimeCurrent(), tp);
    ObjectSetInteger(0, tpName, OBJPROP_COLOR, TPMarkerColor);
    ObjectSetInteger(0, tpName, OBJPROP_WIDTH, 2);
    ObjectSetString(0, tpName, OBJPROP_TEXT, "TP L" + IntegerToString(level));
    ObjectSetInteger(0, tpName, OBJPROP_SELECTABLE, false);
    
    if(level == 1 && sl > 0) {
        string slName = baseName + "_SL";
        ObjectCreate(0, slName, OBJ_ARROW_RIGHT_PRICE, 0, TimeCurrent(), sl);
        ObjectSetInteger(0, slName, OBJPROP_COLOR, SLMarkerColor);
        ObjectSetInteger(0, slName, OBJPROP_WIDTH, 2);
        ObjectSetString(0, slName, OBJPROP_TEXT, "SL L1");
        ObjectSetInteger(0, slName, OBJPROP_SELECTABLE, false);
    }
}

void DrawGridFilledLevel(int level, double price, double tp, double sl) {
    string baseName = "GRID_L" + IntegerToString(level);
    
    string lineName = baseName + "_LINE";
    ObjectCreate(0, lineName, OBJ_HLINE, 0, 0, price);
    ObjectSetInteger(0, lineName, OBJPROP_COLOR, GridFilledColor);
    ObjectSetInteger(0, lineName, OBJPROP_WIDTH, 3);
    ObjectSetInteger(0, lineName, OBJPROP_STYLE, STYLE_SOLID);
    ObjectSetString(0, lineName, OBJPROP_TEXT, "FILLED L" + IntegerToString(level) + " @ " + DoubleToString(price, _Digits));
    ObjectSetInteger(0, lineName, OBJPROP_SELECTABLE, false);
    
    string tpName = baseName + "_TP";
    ObjectCreate(0, tpName, OBJ_ARROW_RIGHT_PRICE, 0, TimeCurrent(), tp);
    ObjectSetInteger(0, tpName, OBJPROP_COLOR, TPMarkerColor);
    ObjectSetInteger(0, tpName, OBJPROP_WIDTH, 2);
    ObjectSetString(0, tpName, OBJPROP_TEXT, "TP L" + IntegerToString(level));
    ObjectSetInteger(0, tpName, OBJPROP_SELECTABLE, false);
    
    if(level == 1 && sl > 0) {
        string slName = baseName + "_SL";
        ObjectCreate(0, slName, OBJ_ARROW_RIGHT_PRICE, 0, TimeCurrent(), sl);
        ObjectSetInteger(0, slName, OBJPROP_COLOR, SLMarkerColor);
        ObjectSetInteger(0, slName, OBJPROP_WIDTH, 2);
        ObjectSetString(0, slName, OBJPROP_TEXT, "SL L1");
        ObjectSetInteger(0, slName, OBJPROP_SELECTABLE, false);
    }
}

void UpdateGridLevelVisual(int level, bool filled) {
    string baseName = "GRID_L" + IntegerToString(level);
    string lineName = baseName + "_LINE";
    
    if(filled) {
        ObjectSetInteger(0, lineName, OBJPROP_COLOR, GridFilledColor);
        ObjectSetInteger(0, lineName, OBJPROP_WIDTH, 3);
        ObjectSetInteger(0, lineName, OBJPROP_STYLE, STYLE_SOLID);
        ObjectSetString(0, lineName, OBJPROP_TEXT, "FILLED L" + IntegerToString(level));
    }
}

void RemoveGridLevelVisual(int level) {
    string baseName = "GRID_L" + IntegerToString(level);
    ObjectDelete(0, baseName + "_LINE");
    ObjectDelete(0, baseName + "_TP");
    ObjectDelete(0, baseName + "_SL");
}

void RemoveGraphicalLines() {
    ObjectDelete(0, "MAIN_POS_LINE");
    ObjectDelete(0, "MAIN_TP_LINE");
    ObjectDelete(0, "GRID_TP_LINE");
    
    for(int i = 1; i <= MaxGridLevels; i++) {
        ObjectDelete(0, "PRED_GRID_" + IntegerToString(i));
        RemoveGridLevelVisual(i);
    }
}

void RemoveAllObjects() {
    ObjectDelete(0, "PANEL_BG");
    ObjectDelete(0, "LBL_TITLE");
    ObjectDelete(0, "LBL_STATUS");
    ObjectDelete(0, "LBL_MAIN_TITLE");
    ObjectDelete(0, "LBL_MAIN_INFO");
    ObjectDelete(0, "LBL_GRID_TITLE");
    ObjectDelete(0, "LBL_GRID_INFO");
    ObjectDelete(0, "LBL_GRID_PROFIT");
    ObjectDelete(0, "LBL_GRID_ORDERS");
    ObjectDelete(0, "LBL_TRAIL_TITLE");
    ObjectDelete(0, "LBL_TRAIL_INFO");
    ObjectDelete(0, "LBL_TRAIL_SHIFTS");
    ObjectDelete(0, "LBL_COOLDOWN_TITLE");
    ObjectDelete(0, "LBL_COOLDOWN_INFO");
    ObjectDelete(0, "LBL_PERF_TITLE");
    ObjectDelete(0, "LBL_TOTAL_PROFIT");
    ObjectDelete(0, "LBL_DRAWDOWN");
    ObjectDelete(0, "LBL_TIME");
    
    ObjectDelete(0, "LBL_BUY");
    ObjectDelete(0, "BTN_BUY_MARKET");
    ObjectDelete(0, "BTN_BUY_LIMIT");
    ObjectDelete(0, "BTN_BUY_STOP");
    
    ObjectDelete(0, "LBL_SELL");
    ObjectDelete(0, "BTN_SELL_MARKET");
    ObjectDelete(0, "BTN_SELL_LIMIT");
    ObjectDelete(0, "BTN_SELL_STOP");
    
    ObjectDelete(0, "BTN_CLOSE_ALL");
    
    RemoveGraphicalLines();
}

void CreateLabel(string name, int x, int y, string text, color clr, int fontSize, string font = "Arial") {
    ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetInteger(0, name, OBJPROP_COLOR, clr);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, fontSize);
    ObjectSetString(0, name, OBJPROP_FONT, font);
}

void CreateButton(string name, int x, int y, int width, int height, string text, color clr) {
    ObjectCreate(0, name, OBJ_BUTTON, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, width);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, height);
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetInteger(0, name, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, clr);
    ObjectSetInteger(0, name, OBJPROP_BORDER_COLOR, clrBlack);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, 9);
}

void CreateRectangle(string name, int x, int y, int width, int height, color clr) {
    ObjectCreate(0, name, OBJ_RECTANGLE_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, width);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, height);
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, clr);
    ObjectSetInteger(0, name, OBJPROP_BORDER_TYPE, BORDER_FLAT);
    ObjectSetInteger(0, name, OBJPROP_BORDER_COLOR, clrBlack);
}

//+------------------------------------------------------------------+
//|              END OF YOU TRADE EA v1.3 FINAL - DUAL CONTROL        |
//+==================================================================+
